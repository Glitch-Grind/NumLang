<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>NumLang Editor</title>

<style>
@font-face {
    font-family: "JetBrainsMono";
    src: url("fonts/JetBrainsMono-Regular.woff2") format("woff2");
}

body {
    margin: 0;
    background: #0f111a;
    overflow: hidden;
    font-family: "JetBrainsMono", Consolas, monospace;
}

/* UI Panel */
#ui {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 320px;
}

button {
    background: #7aa2f7;
    border: none;
    color: black;
    padding: 8px 16px;
    font-family: "JetBrainsMono";
    cursor: pointer;
    border-radius: 6px;
    font-size: 14px;
}

button:hover {
    background: #89b4fa;
}

pre {
    background: #1a1b26;
    color: #c0caf5;
    padding: 12px;
    margin-top: 10px;
    height: 220px;
    overflow-y: auto;
    border-radius: 6px;
    font-size: 14px;
}

canvas {
    display: block;
}
</style>
</head>

<body>

<div id="ui">
    <button onclick="runCode()">Run</button>
    <pre id="output">Ready.</pre>
</div>

<canvas id="editor"></canvas>

<script>
const canvas = document.getElementById("editor");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let lines = [""];
let cursorX = 0;
let cursorY = 0;
let showCaret = true;

const fontSize = 16;
const lineHeight = 24;
const padding = 60;

ctx.font = fontSize + "px JetBrainsMono, Consolas, monospace";

function draw() {
    ctx.fillStyle = "#0f111a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    lines.forEach((line, i) => {
        const y = (i + 1) * lineHeight;

        // Line numbers
        ctx.fillStyle = "#3b4261";
        ctx.fillText(i + 1, 20, y);

        drawHighlightedText(line, padding, y);
    });

    if (showCaret) drawCaret();
}

function drawHighlightedText(text, x, y) {
    const tokens = text.split(/(\s+)/);
    let offsetX = x;

    tokens.forEach(token => {
        ctx.fillStyle = getTokenColor(token);
        ctx.fillText(token, offsetX, y);
        offsetX += ctx.measureText(token).width;
    });
}

function getTokenColor(token) {
    if (/^\d+(\.\d+)?$/.test(token)) return "#89ddff";
    if (/^(let|print)$/.test(token)) return "#c792ea";
    if (/^(sqrt|sin|cos|tan|log)$/.test(token)) return "#82aaff";
    if (/^[=+\-*/^()]+$/.test(token)) return "#ffcb6b";
    return "#d4d4d4";
}

function drawCaret() {
    const textBeforeCursor = lines[cursorY].slice(0, cursorX);
    const x = padding + ctx.measureText(textBeforeCursor).width;
    const y = cursorY * lineHeight + 8;

    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x, y, 2, lineHeight - 10);
}

/* Blinking caret */
setInterval(() => {
    showCaret = !showCaret;
    draw();
}, 500);

document.addEventListener("keydown", e => {
    const line = lines[cursorY];

    if (e.key === "Backspace") {
        if (cursorX > 0) {
            lines[cursorY] =
                line.slice(0, cursorX - 1) +
                line.slice(cursorX);
            cursorX--;
        } 
        else if (cursorY > 0) {
            cursorX = lines[cursorY - 1].length;
            lines[cursorY - 1] += line;
            lines.splice(cursorY, 1);
            cursorY--;
        }
    }

    else if (e.key === "Enter") {
        const newLine = line.slice(cursorX);
        lines[cursorY] = line.slice(0, cursorX);
        lines.splice(cursorY + 1, 0, newLine);

        cursorY++;
        cursorX = 0;
    }

    else if (e.key === "ArrowLeft") {
        if (cursorX > 0) cursorX--;
        else if (cursorY > 0) {
            cursorY--;
            cursorX = lines[cursorY].length;
        }
    }

    else if (e.key === "ArrowRight") {
        if (cursorX < line.length) cursorX++;
        else if (cursorY < lines.length - 1) {
            cursorY++;
            cursorX = 0;
        }
    }

    else if (e.key === "ArrowUp") {
        if (cursorY > 0) {
            cursorY--;
            cursorX = Math.min(cursorX, lines[cursorY].length);
        }
    }

    else if (e.key === "ArrowDown") {
        if (cursorY < lines.length - 1) {
            cursorY++;
            cursorX = Math.min(cursorX, lines[cursorY].length);
        }
    }

    else if (e.key.length === 1) {
        lines[cursorY] =
            line.slice(0, cursorX) +
            e.key +
            line.slice(cursorX);

        cursorX++;
    }

    draw();
});

/* Run Button Logic */
function runCode() {
    const code = lines.join("\n");

    fetch("http://localhost:5000/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: code })
    })
    .then(res => res.text())
    .then(result => {
        document.getElementById("output").textContent = result;
    })
    .catch(err => {
        document.getElementById("output").textContent =
            "Error connecting to server: " + err;
    });
}

draw();
</script>

</body>
</html>
