<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>NumLang Editor</title>
<!-- React and ReactDOM -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<!-- Babel Standalone for JSX -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
@font-face {
    font-family: "JetBrainsMono";
    src: url("fonts/JetBrainsMono-Regular.woff2") format("woff2");
}

* {
    box-sizing: border-box;
}

:root {
    /* Dark theme (default) */
    --bg-primary: #0f111a;
    --bg-secondary: #1a1b26;
    --bg-tertiary: rgba(26, 27, 38, 0.8);
    --text-primary: #c0caf5;
    --text-secondary: #3b4261;
    --text-tertiary: #d4d4d4;
    --accent: #7aa2f7;
    --accent-hover: #89b4fa;
    --accent-light: #a5c9ff;
    --button-text: #0f111a;
    --border: rgba(192, 202, 245, 0.1);
    --success: #9ece6a;
    --error: #f7768e;
    --line-number: #3b4261;
    --caret: #ffffff;
}

body.light-theme {
    /* Light theme */
    --bg-primary: #ffffff;
    --bg-secondary: #f5f5f5;
    --bg-tertiary: rgba(245, 245, 245, 0.8);
    --text-primary: #2d3748;
    --text-secondary: #a0aec0;
    --text-tertiary: #4a5568;
    --accent: #4299e1;
    --accent-hover: #3182ce;
    --accent-light: #63b3ed;
    --button-text: #ffffff;
    --border: rgba(45, 55, 72, 0.1);
    --success: #48bb78;
    --error: #f56565;
    --line-number: #a0aec0;
    --caret: #2d3748;
}

body {
    margin: 0;
    background: var(--bg-primary);
    overflow: hidden;
    font-family: "JetBrainsMono", Consolas, monospace;
    transition: background-color 0.3s ease;
}

/* UI Panel */
#ui {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 360px;
    z-index: 1000;
}

#ui-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

#file-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

#file-buttons button {
    flex: 1;
    padding: 8px 12px;
    font-size: 13px;
}

#file-input {
    display: none;
}

#ui-title {
    color: var(--text-primary);
    font-size: 16px;
    font-weight: 600;
    margin: 0;
    flex: 1;
    transition: color 0.3s ease;
}

button {
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
    border: none;
    color: var(--button-text);
    transition: all 0.3s ease;
    padding: 10px 20px;
    font-family: "JetBrainsMono", Consolas, monospace;
    cursor: pointer;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(122, 162, 247, 0.3);
    position: relative;
    overflow: hidden;
}

button:hover {
    background: linear-gradient(135deg, var(--accent-hover) 0%, var(--accent-light) 100%);
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(122, 162, 247, 0.4);
}

#theme-toggle {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 8px 12px;
    font-size: 18px;
    min-width: 44px;
    transition: all 0.3s ease;
}

#theme-toggle:hover {
    background: var(--bg-tertiary);
    transform: rotate(180deg);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(122, 162, 247, 0.3);
}

button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

button.running::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 16px;
    height: 16px;
    margin: -8px 0 0 -8px;
    border: 2px solid #0f111a;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

#output-container {
    background: var(--bg-secondary);
    border-radius: 10px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    overflow: hidden;
    border: 1px solid var(--border);
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

#output-header {
    background: var(--bg-tertiary);
    padding: 10px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

#output-header::before {
    content: '‚ñ∂';
    color: var(--accent);
    font-size: 10px;
    transition: color 0.3s ease;
}

#output-label {
    color: var(--text-primary);
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin: 0;
    transition: color 0.3s ease;
}

pre {
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 16px;
    margin: 0;
    height: 240px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.6;
    font-family: "JetBrainsMono", Consolas, monospace;
    transition: background-color 0.3s ease, color 0.3s ease;
}

pre::-webkit-scrollbar {
    width: 8px;
}

pre::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
}

pre::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
}

pre::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

pre.error {
    color: var(--error);
}

pre.success {
    color: var(--success);
}

canvas {
    display: block;
    outline: none;
    cursor: text;
}

canvas:focus {
    outline: none;
}

/* Animations */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

@keyframes successFlash {
    0% { background-color: rgba(158, 206, 106, 0.3); }
    100% { background-color: transparent; }
}

@keyframes errorFlash {
    0% { background-color: rgba(247, 118, 142, 0.3); }
    100% { background-color: transparent; }
}

.fade-in {
    animation: fadeIn 0.3s ease-out;
}

.slide-in {
    animation: slideIn 0.4s ease-out;
}

.pulse {
    animation: pulse 0.5s ease-in-out;
}

.shake {
    animation: shake 0.5s ease-in-out;
}

.success-flash {
    animation: successFlash 0.5s ease-out;
}

.error-flash {
    animation: errorFlash 0.5s ease-out;
}

/* React component styles */
.react-ui {
    animation: fadeIn 0.5s ease-out;
}

button {
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}

button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:active::before {
    width: 300px;
    height: 300px;
}

button:active {
    transform: scale(0.95);
}

#output-container {
    transition: all 0.3s ease;
}

#output-container pre {
    transition: all 0.3s ease;
}

/* Smooth transitions for React state changes */
#ui {
    transition: opacity 0.3s ease, transform 0.3s ease;
}

#file-buttons button {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

#file-buttons button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(122, 162, 247, 0.4);
}

/* Responsive */
@media (max-width: 768px) {
    #ui {
        width: calc(100% - 40px);
        max-width: 360px;
    }
}
</style>
</head>

<body>

<div id="react-root"></div>
<input type="file" id="file-input" accept=".numlang,.nl" style="display: none;" />

<canvas id="editor" tabindex="0"></canvas>

<script>
const canvas = document.getElementById("editor");
const ctx = canvas.getContext("2d");

let lines = [""];
let cursorX = 0;
let cursorY = 0;
let showCaret = true;
let errorLines = new Set(); // Track lines with errors
let indentLevel = 0; // Track indentation level
let currentFileName = null; // Track current file name

const fontSize = 16;
const lineHeight = 24;
const padding = 60;

function setFont() {
    ctx.font = fontSize + "px JetBrainsMono, Consolas, monospace";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    setFont(); // Reset font after canvas resize (context is reset)
    draw();
}

function getThemeColor(cssVar) {
    const root = document.documentElement;
    return getComputedStyle(root).getPropertyValue(cssVar).trim();
}

function draw() {
    const bgColor = getThemeColor('--bg-primary');
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const errorColor = getThemeColor('--error');
    const lineNumberColor = getThemeColor('--line-number');
    const errorBgColor = errorColor + "33"; // Add transparency

    lines.forEach((line, i) => {
        const y = i * lineHeight + 4; // Top baseline, add small padding

        // Highlight error lines
        if (errorLines.has(i + 1)) {
            ctx.fillStyle = errorBgColor;
            ctx.fillRect(0, y - 2, canvas.width, lineHeight);
        }

        // Line numbers
        ctx.fillStyle = errorLines.has(i + 1) ? errorColor : lineNumberColor;
        ctx.fillText((i + 1).toString(), 20, y);

        drawHighlightedText(line, padding, y);
    });

    if (showCaret) drawCaret();
}

function drawHighlightedText(text, x, y) {
    // Improved tokenization to handle operators and keywords better
    const tokens = [];
    let currentToken = "";
    let i = 0;
    
    while (i < text.length) {
        const char = text[i];
        const nextChar = i + 1 < text.length ? text[i + 1] : "";
        
        // Handle multi-character operators
        if ((char === '>' && nextChar === '=') || 
            (char === '<' && nextChar === '=') ||
            (char === '=' && nextChar === '=') ||
            (char === '!' && nextChar === '=')) {
            if (currentToken) {
                tokens.push(currentToken);
                currentToken = "";
            }
            tokens.push(char + nextChar);
            i += 2;
            continue;
        }
        
        // Handle single-character operators and separators
        if (/[\s+\-*/^()%=<>!]/.test(char)) {
            if (currentToken) {
                tokens.push(currentToken);
                currentToken = "";
            }
            if (!/\s/.test(char)) {
                tokens.push(char);
            } else {
                tokens.push(" "); // Preserve spaces
            }
            i++;
            continue;
        }
        
        currentToken += char;
        i++;
    }
    
    if (currentToken) {
        tokens.push(currentToken);
    }
    
    let offsetX = x;
    tokens.forEach(token => {
        if (token.trim() || token === " ") {
            ctx.fillStyle = getTokenColor(token);
            ctx.fillText(token, offsetX, y);
            offsetX += ctx.measureText(token).width;
        }
    });
}

function getTokenColor(token) {
    const isLight = document.body.classList.contains('light-theme');
    
    // Numbers
    if (/^\d+(\.\d+)?$/.test(token)) return isLight ? "#2563eb" : "#89ddff";
    
    // Keywords
    if (/^(let|print|if|then|for|do|end|function)$/.test(token)) return isLight ? "#9333ea" : "#c792ea";
    
    // Math functions
    if (/^(sqrt|abs|floor|ceil|round|exp|pow|sin|cos|tan|asin|acos|atan|deg|rad|log|log10|log2)$/.test(token)) return isLight ? "#3b82f6" : "#82aaff";
    
    // Constants
    if (/^(pi|e|tau|inf|nan)$/.test(token)) return isLight ? "#0284c7" : "#7dcfff";
    
    // Operators
    if (/^[=+\-*/^()%]+$/.test(token)) return isLight ? "#ea580c" : "#ffcb6b";
    
    // Comparison operators
    if (/^(>=|<=|==|!=|>|<)$/.test(token)) return isLight ? "#dc2626" : "#ff9e64";
    
    return getThemeColor('--text-tertiary');
}

function drawCaret() {
    const textBeforeCursor = lines[cursorY].slice(0, cursorX);
    const x = padding + ctx.measureText(textBeforeCursor).width;
    const y = cursorY * lineHeight + 4; // Match text y position

    const caretColor = getThemeColor('--caret');
    ctx.fillStyle = caretColor;
    ctx.fillRect(x, y, 2, fontSize);
}

/* Blinking caret */
setInterval(() => {
    showCaret = !showCaret;
    draw();
}, 500);

document.addEventListener("keydown", e => {
    // Ignore keyboard events if user is typing in an input field
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable) {
        return;
    }
    
    // Keyboard shortcuts
    if (e.ctrlKey || e.metaKey) {
        if (e.key === "s") {
            e.preventDefault();
            saveFile();
            return;
        }
        if (e.key === "o") {
            e.preventDefault();
            openFile();
            return;
        }
    }
    
    // Focus canvas if it's not focused
    if (document.activeElement !== canvas) {
        canvas.focus();
    }
    
    const line = lines[cursorY];

    if (e.key === "Backspace") {
        if (cursorX > 0) {
            lines[cursorY] =
                line.slice(0, cursorX - 1) +
                line.slice(cursorX);
            cursorX--;
        } 
        else if (cursorY > 0) {
            cursorX = lines[cursorY - 1].length;
            lines[cursorY - 1] += line;
            lines.splice(cursorY, 1);
            cursorY--;
        }
    }

    else if (e.key === "Enter") {
        const newLine = line.slice(cursorX);
        lines[cursorY] = line.slice(0, cursorX);
        
        // Auto-indentation
        const currentLine = lines[cursorY];
        let indent = 0;
        
        // Check for indentation triggers
        const trimmed = currentLine.trim();
        if (trimmed.startsWith("if ") || trimmed.startsWith("for ") || trimmed.startsWith("function ")) {
            indent = 1;
        } else if (trimmed === "end" || trimmed.startsWith("end ")) {
            indent = -1;
        }
        
        // Calculate current indentation
        let currentIndent = 0;
        for (let i = 0; i < currentLine.length && currentLine[i] === ' '; i++) {
            currentIndent++;
        }
        
        // Apply new indentation (4 spaces per level)
        const newIndent = Math.max(0, Math.floor(currentIndent / 4) + indent) * 4;
        const indentStr = " ".repeat(newIndent);
        
        lines.splice(cursorY + 1, 0, indentStr + newLine);
        cursorY++;
        cursorX = newIndent;
    }

    else if (e.key === "ArrowLeft") {
        if (cursorX > 0) cursorX--;
        else if (cursorY > 0) {
            cursorY--;
            cursorX = lines[cursorY].length;
        }
    }

    else if (e.key === "ArrowRight") {
        if (cursorX < line.length) cursorX++;
        else if (cursorY < lines.length - 1) {
            cursorY++;
            cursorX = 0;
        }
    }

    else if (e.key === "ArrowUp") {
        if (cursorY > 0) {
            cursorY--;
            cursorX = Math.min(cursorX, lines[cursorY].length);
        }
    }

    else if (e.key === "ArrowDown") {
        if (cursorY < lines.length - 1) {
            cursorY++;
            cursorX = Math.min(cursorX, lines[cursorY].length);
        }
    }

    else if (e.key.length === 1) {
        lines[cursorY] =
            line.slice(0, cursorX) +
            e.key +
            line.slice(cursorX);

        cursorX++;
    }

    draw();
});

/* Run Button Logic */
function runCode() {
    const code = lines.join("\n");
    
    // Update React state
    if (window.setRunning) window.setRunning(true);
    if (window.updateOutput) window.updateOutput("Running code...", "", false);
    
    fetch("http://localhost:5000/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: code })
    })
    .then(res => res.text())
    .then(result => {
        // Clear previous error lines
        errorLines.clear();
        
        // Parse error messages to find line numbers
        const errorPattern = /Line (\d+):/g;
        let match;
        while ((match = errorPattern.exec(result)) !== null) {
            const lineNum = parseInt(match[1]);
            errorLines.add(lineNum);
        }
        
        // Check if there are errors
        const hasErrors = errorLines.size > 0 || result.toLowerCase().includes("error");
        const className = hasErrors ? "error" : "success";
        
        // Update React state with animation
        if (window.updateOutput) window.updateOutput(result, className, true);
        
        // Redraw to show error highlighting
        draw();
    })
    .catch(err => {
        errorLines.clear();
        const errorMsg = "Error connecting to server: " + err;
        if (window.updateOutput) window.updateOutput(errorMsg, "error", true);
        draw();
    })
    .finally(() => {
        // Re-enable button
        if (window.setRunning) window.setRunning(false);
    });
}

// File operations
function openFile() {
    const fileInput = document.getElementById("file-input");
    fileInput.click();
    
    fileInput.addEventListener("change", function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            // Split content into lines
            lines = content.split("\n");
            if (lines.length === 0) lines = [""];
            
            // Store filename
            currentFileName = file.name;
            
            // Reset cursor
            cursorY = 0;
            cursorX = 0;
            
            // Clear errors
            errorLines.clear();
            
            // Redraw editor
            draw();
            
            // Update React state
            if (window.setFileStatus) window.setFileStatus(`‚úì Opened: ${file.name}`);
            if (window.updateOutput) window.updateOutput(`Opened: ${file.name}`, "success", true);
        };
        reader.readAsText(file);
        
        // Reset file input
        fileInput.value = "";
    }, { once: true });
}

function saveFile() {
    const code = lines.join("\n");
    
    if (!code.trim()) {
        if (window.updateOutput) window.updateOutput("Nothing to save - editor is empty", "error", true);
        return;
    }
    
    // Use current filename if available, otherwise default to script.numlang
    let fileName = currentFileName || "script.numlang";
    
    // Ensure .numlang extension
    if (!fileName.endsWith(".numlang") && !fileName.endsWith(".nl")) {
        fileName = fileName.replace(/\.[^/.]+$/, "") + ".numlang";
    }
    
    // Create blob with .numlang extension
    const blob = new Blob([code], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    
    // Create download link
    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // Clean up
    URL.revokeObjectURL(url);
    
    // Update React state
    if (window.setFileStatus) window.setFileStatus(`‚úì Saved: ${fileName}`);
    if (window.updateOutput) window.updateOutput(`File saved as ${fileName}`, "success", true);
}

</script>

<script type="text/babel">
// React Components
const { useState, useEffect, useRef } = React;

function UIComponent() {
    // Load theme from localStorage or default to dark
    const [isDarkMode, setIsDarkMode] = useState(() => {
        const saved = localStorage.getItem('numlang-theme');
        return saved !== 'light';
    });
    const [output, setOutput] = useState("Ready. Click Run to execute your code.");
    const [outputClass, setOutputClass] = useState("");
    const [isRunning, setIsRunning] = useState(false);
    const [fileStatus, setFileStatus] = useState("");
    const [animationClass, setAnimationClass] = useState("");
    const outputRef = useRef(null);

    // Apply theme on mount and when it changes
    useEffect(() => {
        if (isDarkMode) {
            document.body.classList.remove('light-theme');
        } else {
            document.body.classList.add('light-theme');
        }
        localStorage.setItem('numlang-theme', isDarkMode ? 'dark' : 'light');
        
        // Redraw canvas with new theme colors
        if (typeof draw === 'function') {
            draw();
        }
    }, [isDarkMode]);

    useEffect(() => {
        // Expose functions to global scope for canvas editor
        window.updateOutput = (text, className, animate = false) => {
            setOutput(text);
            setOutputClass(className);
            if (animate) {
                if (className === "success") {
                    setAnimationClass("success-flash");
                } else if (className === "error") {
                    setAnimationClass("error-flash");
                }
                setTimeout(() => setAnimationClass(""), 500);
            }
        };

        window.setRunning = (running) => {
            setIsRunning(running);
        };

        window.setFileStatus = (status) => {
            setFileStatus(status);
            setTimeout(() => setFileStatus(""), 3000);
        };
    }, []);

    const handleRun = () => {
        setIsRunning(true);
        setAnimationClass("pulse");
        setTimeout(() => setAnimationClass(""), 500);
        runCode();
    };

    const handleOpen = () => {
        setAnimationClass("slide-in");
        setTimeout(() => setAnimationClass(""), 400);
        openFile();
    };

    const handleSave = () => {
        setAnimationClass("pulse");
        setTimeout(() => setAnimationClass(""), 500);
        saveFile();
    };

    const toggleTheme = () => {
        setIsDarkMode(!isDarkMode);
        setAnimationClass("pulse");
        setTimeout(() => setAnimationClass(""), 500);
    };

    return (
        <div id="ui" className={`react-ui ${animationClass}`}>
            <div id="ui-header" className="fade-in">
                <h3 id="ui-title">NumLang Editor</h3>
                <button 
                    id="theme-toggle"
                    onClick={toggleTheme}
                    title={isDarkMode ? "Switch to light mode" : "Switch to dark mode"}
                >
                    {isDarkMode ? "üåô" : "‚òÄÔ∏è"}
                </button>
                <button 
                    id="run-button" 
                    onClick={handleRun}
                    disabled={isRunning}
                    className={isRunning ? "running" : ""}
                >
                    {isRunning ? "‚è≥ Running" : "‚ñ∂ Run"}
                </button>
            </div>
            <div id="file-buttons" className="slide-in">
                <button onClick={handleOpen}>üìÇ Open</button>
                <button onClick={handleSave}>üíæ Save</button>
            </div>
            {fileStatus && (
                <div style={{
                    padding: "8px",
                    marginBottom: "12px",
                    background: "var(--bg-tertiary)",
                    borderRadius: "6px",
                    fontSize: "12px",
                    color: "var(--text-primary)",
                    border: "1px solid var(--border)",
                    animation: "fadeIn 0.3s ease-out"
                }}>
                    {fileStatus}
                </div>
            )}
            <div id="output-container" className={`${animationClass}`}>
                <div id="output-header">
                    <span id="output-label">Output</span>
                </div>
                <pre 
                    id="output" 
                    ref={outputRef}
                    className={outputClass}
                    style={{
                        animation: outputClass ? (outputClass === "success" ? "successFlash 0.5s" : "errorFlash 0.5s") : ""
                    }}
                >
                    {output}
                </pre>
            </div>
        </div>
    );
}

// Render React component
const root = ReactDOM.createRoot(document.getElementById('react-root'));
root.render(<UIComponent />);
</script>

<script>
// Initialize canvas and event listeners
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Focus canvas on click and on page load
canvas.addEventListener("click", () => {
    canvas.focus();
});

// Focus canvas when page loads
window.addEventListener("load", () => {
    canvas.focus();
    draw(); // Ensure initial draw
});

// Expose redraw function for theme changes
window.redrawCanvas = () => {
    draw();
};

// Listen for theme changes and redraw
const observer = new MutationObserver(() => {
    if (typeof draw === 'function') {
        draw();
    }
});

observer.observe(document.body, {
    attributes: true,
    attributeFilter: ['class']
});
</script>

</body>
</html>
